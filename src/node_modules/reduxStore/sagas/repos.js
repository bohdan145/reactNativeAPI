import {
  fork, takeEvery, call, put, takeLeading, select, delay,
} from 'redux-saga/effects';
import { SearchRepo, LoadMore } from 'reduxStore/actions/repos';
import { apiCall } from 'utils';
import queryString from 'query-string';

const handleSearch = ({ searchStr = '', page }) => {
  const params = {
    q: searchStr,
    per_page: 15,
    page,
  };

  return apiCall.get(`search/repositories?${queryString.stringify(params)}`);
};

function* watchSearch() {
  yield takeEvery(SearchRepo.TRIGGER, function* search({ payload: searchStr }) {
    try {
      yield put(SearchRepo.request());

      const { data } = yield call(handleSearch, { searchStr, page: 1 });

      if (data.items.length) {
        yield put(SearchRepo.success({ searchStr, data: data.items, totalCount: data.total_count }));
      }
    } catch (e) {
      console.log(e.message);
    } finally {
      yield put(SearchRepo.fulfill());
    }
  });
}

function* watchLoadMore() {
  yield takeLeading(LoadMore.TRIGGER, function* load() {
    try {
      const {
        searchStr, page, itemsCount, totalCount, list,
      } = yield select(state => state.repos);

      yield put(LoadMore.request());
      // yield delay(500)

      if (itemsCount < totalCount) {
        const { data } = yield call(handleSearch, { searchStr, page });

        if (data.items.length) {
          // First item in response could be the same as the last one in the list
          if (data.items[0].id === list[list.length - 1].id) {
            const [first, ...rest] = data.items;
            yield put(LoadMore.success({ data: rest }));
          } else {
            yield put(LoadMore.success({ data: data.items }));
          }
        }
      }
    } catch (e) {
      console.log(e.message);
    } finally {
      yield put(LoadMore.fulfill());
    }
  });
}

function* repoSaga() {
  yield fork(watchSearch);
  yield fork(watchLoadMore);
}

export default repoSaga;
